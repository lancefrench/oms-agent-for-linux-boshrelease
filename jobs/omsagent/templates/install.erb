#!/bin/bash

# Primary Variables
PRODUCT="omsagent"
INSTALL_DIR="/var/vcap"
SYSLOG_DIR="${INSTALL_DIR}/sys/log"
PKG_DIR="${INSTALL_DIR}/packages/${PRODUCT}"
DATA_DIR="${INSTALL_DIR}/data"
INSTALLER=""
DPKG_TIMEOUT=300
DPKG_INSTALL_OPTS=("--force-confold" "--force-confdef")
RPM_INSTALL_OPTS=("--force")
CONTROLLER=""

# Template Variables
workspace_id=<%= p('oms.workspace_id') %>
workspace_key=<%= p('oms.workspace_key') %>
oms_top_level_domain=<%= p('oms.top_level_domain', "opinsights.azure.com") %>
rsyslog_port=<%= p('rsyslog.port', 25224) %>

# Package Variables and Versions
pkg_list=("omsconfig" "omsagent" "scx" "omi")

## omsagent 
omsagent_pkg="omsagent"
omsagent_ver="1.12.15-0.universal.x64"
omsagent_path="${PKG_DIR}/${omsagent_pkg}-${omsagent_ver}"

## omsconfig
omsconfig_pkg="omsconfig"
omsconfig_ver="1.1.1-927.x64"
omsconfig_path="${PKG_DIR}/${omsconfig_pkg}-${omsconfig_ver}"

## omi
omi_pkg="omi"
omi_ver="1.6.3-0.ulinux.x64"
omi_path="${PKG_DIR}/${omi_pkg}-${omi_ver}"

## scx
scx_pkg="scx"
scx_ver="1.6.3-1079.universal.x64"
scx_path="${PKG_DIR}/${scx_pkg}-${scx_ver}"

# Utilize the functions later
source "${PKG_DIR}/utils.sh"

# Exit Codes
DETECT_INSTALLER_FAILURE=65
DETECT_CONTROLLER_FAILURE=66
STOP_OMS_SERVICE_NO_SERVICE=67
PKG_CONTROL_NO_PACKAGE=68
PKG_CONTROL_INVALID_ACTION=69

# Wrapper for exiting
## $1 - exit code
trigger_exit(){
    echo "ERROR: pre-start script exiting with code ${1}"
    exit "${1}" 
}

# Verify the OS has dpkg or rpm package installer
detect_installer(){
    # Detect dpkg first
    which dpkg > /dev/null 2>&1 && INSTALLER="DPKG"

    # If dpkg wasn't found, check for rpm
    if [[ -z "${INSTALLER}" ]]; then
        which rpm > /dev/null 2>&1 && INSTALLER="RPM"

        # If rpm and dpkg aren't found, script needs to fail and exit
        if [[ -z "${INSTALLER}" ]]; then
            echo "ERROR: Unable to detect a valid installer binary. \
Valid installers are either \"dpkg\" or \"rpm\".

Either the PATH environment variable needs updated, or this script is being \
executed on an unsupported OS." >&2

            trigger_exit "${DETECT_INSTALLER_FAILURE}"
        fi
    fi
}

# Check if omsagent is already installed
detect_existing_install(){
    # This section checks for existing omsagent and omsconfig packages already installed.
    if [[ "${INSTALLER}" = "DPKG" ]]; then
        dpkg -s "${pkg_list[@]}" 2> /dev/null | grep "^Status:" | grep installed > /dev/null 2>&1
        OMS_FOUND="${?}"
    else
        rpm -q "${pkg_list[@]}" > /dev/null 2>&1
        OMS_FOUND="${?}"
    fi
}

# Detect the service controller
detect_controller(){
    # Check the PATH for systemctl
    if which systemctl > /dev/null 2>&1; then
        CONTROLLER="systemctl"

    # Check for the binaries directly
    else
        if [[ -f "/bin/systemctl" ]]; then
            CONTROLLER="systemctl"
        elif [[ -f "/sbin/service" ]]; then
            CONTROLLER="service"
        elif [[ -f "/usr/sbin/invoke-rc.d" ]]; then
            CONTROLLER="invoke-rc.d"
        fi
    fi

    # Exit if no supported controllers found
    if [[ -z "${CONTROLLER}" ]]; then
        echo "ERROR: Unable to detect a supported controller.
Supported Controllers are 'systemctl', 'service' and 'invoke-rc'." >&2

        trigger_exit "${DETECT_CONTROLLER_FAILURE}"
    fi
}

# Function for stopping, disabling and killing 
stop_oms_services(){
    # Initializing variables
    local service_stop=""
    local service_disable=""
    local service_kill=""
    local sev=""
    local sev_arry=()

    # Regex for detecting the omsagent service
    reg="omsagent-[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}"

    # Loop through any options provided
    for stop_val in "${@}"; do
        if [[ "${stop_val}" == "stop" ]]; then
            service_stop="true"
        fi

        if [[ "${stop_val}" == "disable" ]]; then
            service_disable="true"
        fi

        if [[ "${stop_val}" == "kill" ]]; then
            service_kill="true"
        fi

        # Adds omsagent-workspace_id as one of the services to stop/disable/kill
        if [[ "${stop_val}" == "current_ws" ]]; then
            sev_array+=("omsagent-${workspace_id}")
        fi

        if [[ "${stop_val}" == "omsagent" ]]; then
            sev_array+=("omsagent")
        fi

        if [[ "${stop_val}" == "omid" ]]; then
            sev_array+=("omid")
        fi
    done

    # Check if sev_array is empty
    if [[ "${#sev_array[@]}" -eq 0 ]]; then
        echo -e "ERROR: No services provided to stop/disable/kill. Valid services are:
\t'omsagent'
\t'omid'
\t'current_ws' (this will stop/disable/kill 'omsagent-<workspace_id>')" >&2

        trigger_exit "${STOP_OMS_SERVICE_NO_SERVICE}"

    # Proceed if it is not empty
    else
        # Loop through all services added to the array
        for sev in "${sev_array[@]}"; do
            # invoke-rc.d method
            if [[ "${CONTROLLER}" == "invoke-rc.d" ]]; then
                if [[ "${sev}" == "omsagent" ]]; then
                    # Pull the name of the service
                    sev=$(ls /etc/init.d/ | grep -P "${reg}" -o)
                fi
    
                # Try to stop omsagent utilizing the controller
                if [[ "${service_stop}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Stopping ${sev} process via ${CONTROLLER}"
                    "${CONTROLLER}" "${sev}" stop
    
                    # for omid, try stopping it with the scxadmin binary too
                    if [[ "${sev}" == "omid" ]]; then
                        scxadmin -stop all
                    fi
                fi
    
                # Try to disable and wipe out the init scripts
                if [[ "${service_disable}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Attempting to disable ${sev} from starting."
                    update-rc.d "${sev}" disable
                    rm -fv "/etc/init.d/${sev}" 2>/dev/null
                fi
    
            # service method
            elif [[ "${CONTROLLER}" == "service" ]]; then
                if [[ "${sev}" == "omsagent" ]]; then
                    # Pull the name of the service
                    sev=$(service --status-all | grep -P "${reg}" -o)
                fi
    
                # Try to stop omsagent utilizing the controller
                if [[ "${service_stop}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Stopping ${sev} process via ${CONTROLLER}"
                    "${CONTROLLER}" "${sev}" stop
    
                    # for omid, try stopping it with the scxadmin binary too
                    if [[ "${sev}" == "omid" ]]; then
                        scxadmin -stop all
                    fi
                fi
    
                # Try to disable and wipe out the init scripts
                if [[ "${service_disable}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Attempting to disable ${sev} from starting."
                    chkconfig "${sev}" off
                    chkconfig --del "${sev}"
                    rm -fv "/etc/init.d/${sev}" 2>/dev/null
                fi
    
            # systemctl method
            else
                if [[ "${sev}" == "omsagent" ]]; then
                    # Pull the name of the service
                    sev=$("${CONTROLLER}" status | grep -P "${reg}" -o)
                fi
    
                if [[ "${service_stop}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Stopping ${sev} process via ${CONTROLLER}"
                    "${CONTROLLER}" stop "${sev}"
    
                    # for omid, try stopping it with the scxadmin binary too
                    if [[ "${sev}" == "omid" ]]; then
                        scxadmin -stop all
                    fi
                fi
    
                # Try to disable and wipe out the unit files
                if [[ "${service_disable}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Attempting to disable ${sev} from starting."
                    "${CONTROLLER}" disable "${sev}"
                    rm -fv "/lib/systemd/system/${sev}.service" 2>/dev/null
                fi
            fi
    
            if [[ "${service_kill}" == "true" && "${sev}" != "omid" ]]; then
                echo "INFO: Attempting to kill any omsagent PIDs still running..."
    
                # Pull PIDs for any process using the custom rsyslog port for omsagent
                current_pids=$(sudo netstat -anop | grep ${rsyslog_port} | cut -c 81- | cut -d'/' -f 1 | cut -d'-' -f 1)

                # If the array has at least 1 or more PIDs detected, loop through and kill them
                if [[ "${#current_pids[@]}" -gt 0 ]]; then 
                    # Looping through the pids
                    for current_pid in "${current_pids}"; do
                        if [[ -n "${current_pid}" ]]; then
                            echo "INFO: Killing ${current_pid} "
                            kill -9 "${current_pid}"
                        fi
                    done
                fi
    
                # Killing anything still running as the omsagent user
                pkill -u omsagent > /dev/null 2>&1
            fi
        done
    fi
}

# This function is used for installing or removing packages
## $1 - [install|remove] : Tells the funtion it'll be either installing or removing packages
## $2, $3, etc - [all|<pkg name>] : 'all' will install/remove the entire 'pkg_list' array, or 
##                                  you can specify each package and it'll loop through them.
pkg_control(){
    local packages=()
    local install_array=()
    local pkg_action="${1}"

    # Ensure at least one package is provided
    if [[ -z "${2}" ]]; then
        echo -e "ERROR: No packages provided to pkg_control function. Unable to proceed." >&2
        trigger_exit "${PKG_CONTROL_NO_PACKAGE}"
    fi

    # Install packages
    if [[ "${pkg_action}" == "install" ]]; then
        if [[ "${2}" == "all" ]]; then
            install_array=("${pkg_list[@]}")

        else
            for pkg in "${@:2}"; do
                install_array+=("${pkg}")
            done
        fi

        if [[ "${INSTALLER}" = "DPKG" ]]; then
            # Building packages array with paths to each .deb package to install
            for inst_pkg in "${install_array[@]}"; do
                pkg_path="${inst_pkg}_path"
    
                packages+=("${!pkg_path}.deb")
            done

            # Perform the install
            (
            # Get a lock to prevent other bad actors running dpkg commands
            # e.g. bosh running parallel requests that might interfere
            flock -x 200
        
            # Used as a timeout
            DPKG_RETRIES=0
        
            # Checks dpkg/apt related lock files to see if they're already locked and in use
            # Also checks if DPKG_RETRIES hit the timeout value
            while fuser /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock >/dev/null 2>&1 \
&& [ "${DPKG_RETRIES}" -lt "${DPKG_TIMEOUT}" ]; do
                DPKG_RETRIES=$(( DPKG_RETRIES + 1 ))
                sleep 1
            done

            echo "INFO: Installing these packages: ${packages[@]}"
            echo dpkg -i "${DPKG_INSTALL_OPTS}" "${packages[@]}" || true
            ) 200>"${DATA_DIR}/dpkg.lock"

        # RPM
        else
            # Building packages array with paths to each .deb package to install
            for inst_pkg in "${install_array[@]}"; do
                pkg_path="${inst_pkg}_path"

                packages+=("${!pkg_path}.rpm")
            done

            # Perform the install
            echo "INFO: Installing these packages: ${packages[@]}"
            echo rpm -Uvh "${RPM_INSTALL_OPTS}" "${packages[@]}"
        fi

    # Remove packages
    elif [[ "${pkg_action}" == "remove" ]]; then
        # If we're removing all packages
        if [[ "${2}" == "all" ]]; then
            packages=("${pkg_list[@]}")

        # Otherwise build the array from packages provided skipping the first variable
        else
            for pkg in "${@:2}"; do
                packages+=("${pkg}")
            done
        fi

        # DPKG removal
        if [[ "${INSTALLER}" = "DPKG" ]]; then
            # dpkg lock control and perform the removal
            (
            # Get a lock to prevent other bad actors running dpkg commands
            # e.g. bosh running parallel requests that might interfere
            flock -x 200

            # Used as a timeout
            DPKG_RETRIES=0

            # Checks dpkg/apt related lock files to see if they're already locked and in use
            # Also checks if DPKG_RETRIES hit the timeout value
            while fuser /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock >/dev/null 2>&1 \
&& [ "${DPKG_RETRIES}" -lt "${DPKG_TIMEOUT}" ]; do
                DPKG_RETRIES=$(( DPKG_RETRIES + 1 ))
                sleep 1
            done

            echo "INFO: Removing these packages: ${packages[@]}"
            echo dpkg -r "${packages[@]}"
            ) 200>"${DATA_DIR}/dpkg.lock"

        # RPM removal
        else
            echo "INFO: Removing these packages: ${packages[@]}"
            echo rpm -e "${packages[@]}"
        fi
        
    # Enters here if an invalid action is provided
    else
        echo -e "ERROR: Invalid action provided to pkg_control function. Valid actions are:
\t'install'
\t'remove'" >&2

        trigger_exit "${PKG_CONTROL_INVALID_ACTION}"
    fi
}

# This function is used to safely create the necessary symlinks
## $1 - Symlink Existing Source/Target
## $2 - Symlink Link Name
retry_create_symlinks(){
    if [ -z "$1" ] || [ -z "$2" ]; then
        echo "Function \"retry_create_symlinks\" called with invalid parameter"
        exit 1
    fi

    local DIR="${1}"
    local LINK="${2}"

    if [ ! -L $LINK ]; then
        RETRIES=2

        while [ $RETRIES -gt 0 ]; do
            # If $LINK exists and is a directory, backup the logs and then recreate it as a symlink
            if [ -d $LINK ]; then
                mv -f $LINK/* $DIR/
                rm -rf $LINK
            fi

            # Create the symlink
            ln -s $DIR $LINK

            # If the link exists, break out of the loop
            if [ -L $LINK ]; then
                break
            fi

            # Countdown to zero
            RETRIES=$((RETRIES - 1))
        done

        if [ $RETRIES -eq 0 ]; then
            echo "Failed to create symlink $LINK to $DIR"
        fi
    fi
}

main(){
    # Verify the OS has a valid package installer
    detect_installer

    # Detect the service controller
    detect_controller

    # Check if there is an existing omsagent installation
    detect_existing_install

    # Enters here if an existing omsagent installation was found
    if [[ "${OMS_FOUND}" -eq 0 ]]; then
        echo "INFO: Existing omsagent detected. Ensuring it's stopped and disabled."

        # Stop existing omsagent processes
        stop_oms_services stop disable kill omsagent

        # Remove related packages
        pkg_control remove omsconfig omsagent
    fi

    # Check for scx, stop and remove it
    which scxadmin > /dev/null 2>&1

    # If scxadmin is detected
    if [[ "${?}" -eq 0 ]]; then
        echo "INFO: Detected 'scx' installed; stopping and removing related packages."

        # Stop and disable omid which is controlled by scxadmin
        stop_oms_services stop disable omid
    
        # Remove related packages
        pkg_control remove omi scx
    fi

    exit 55
# Removing the file to ensure onboarding is triggered upon re-installation.
# Checks to see if the file exists, and that it is empty.
if [ -f "/etc/opt/microsoft/omsagent/${workspace_id}/conf/.service_registered" -a ! -s "/etc/opt/microsoft/omsagent/${workspace_id}/conf/.service_registered" ]; then
    rm -f "/etc/opt/microsoft/omsagent/${workspace_id}/conf/.service_registered"
fi

# Redirect logs
mkdir -p /var/vcap/sys/log/omi
mkdir -p /var/vcap/sys/log/scx
mkdir -p /var/vcap/sys/log/omsconfig

mkdir -p /var/opt/omi
mkdir -p /var/opt/microsoft/scx

retry_create_symlinks /var/vcap/sys/log/omi /var/opt/omi/log
retry_create_symlinks /var/vcap/sys/log/scx /var/opt/microsoft/scx/log
retry_create_symlinks /var/vcap/sys/log/omsconfig /var/opt/microsoft/omsconfig

cp -f /var/vcap/packages/omsagent/logrotate.scx.conf /etc/logrotate.d/scx

# Write the onboard config
cat <<EOF > /etc/omsagent-onboard.conf
WORKSPACE_ID=$workspace_id
SHARED_KEY=$workspace_key
URL_TLD=$oms_top_level_domain
EOF

# Setup user account and permission
echo "Using identity $(id)"

count=$(grep -c '^omsagent:' /etc/group)
if [ "$count" == 0 ]; then
    # Create new user group omsagent
    groupadd -f "omsagent"
fi

count=$(grep -c '^omiusers:' /etc/group)
if [ "$count" == 0 ]; then
    # Create new user group omiusers
    groupadd -f "omiusers"
fi

count=$(grep -c '^omsagent:' /etc/passwd)
if [ "$count" == 0 ]; then
    # Create new user account omsagent
    useradd -M -N -s /bin/bash "omsagent"
fi

usermod -aG omsagent omsagent
usermod -aG omiusers omsagent

chown -h omsagent:omsagent /var/opt/microsoft/omsconfig
chown -h omsagent:omiusers /var/opt/microsoft/omsconfig
chown -h omsagent:omsagent /var/vcap/sys/log/omsconfig

# Add oms users to vcap group for file system access
usermod -aG vcap omsagent
usermod -aG vcap nxautomation

# Install packages
if [ ${DPKG_FOUND} -eq 0 ]; then
    (
    # Get a lock to prevent other bad actors running dpkg commands
    # e.g. bosh running parallel requests that might interfere
    flock -x 200

    # Used as a timeout
    DPKG_RETRIES=0

    # Checks dpkg/apt related lock files to see if they're already locked and in use
    # Also checks if DPKG_RETRIES hit the timeout value
    while fuser /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock >/dev/null 2>&1 \
&& [ "${DPKG_RETRIES}" -lt 300 ]; do
        DPKG_RETRIES=$(( DPKG_RETRIES + 1 ))
        sleep 1
    done

    dpkg -i --force-confold --force-confdef /var/vcap/packages/omsagent/omi*.deb /var/vcap/packages/omsagent/scx*.deb /var/vcap/packages/omsagent/omsagent*.deb /var/vcap/packages/omsagent/omsconfig*.deb || true
    ) 200>/var/vcap/data/dpkg.lock

    # Initializing to zero
    pkg_count=0

    # Get a count on the packages to see if all four were installed
    pkg_count=$(dpkg -l omsagent omsconfig omi scx | grep -c "^ii ")

    # Output some information and exit if all packages are not found.
    if [[ "${pkg_count}" -ne 4 ]]; then
        echo "Expected to find 4 packages, however only ${pkg_count} were detected. Some of the required \
omsagent packages are missing. Exiting the installation as it has failed to install all packages."
        exit 50
    fi

else
    rpm -Uvh --force /var/vcap/packages/omsagent/omi-*.rpm /var/vcap/packages/omsagent/scx*.rpm /var/vcap/packages/omsagent/omsagent*.rpm /var/vcap/packages/omsagent/omsconfig*.rpm || true

    # Initializing to zero
    pkg_count=0

    # Get a count on the packages to see if all four were installed
    pkg_count=$(rpm -q omsagent omsconfig omi scx | grep -v "is not installed" | wc -l)

    # Output some information and exit if all packages are not found.
    if [[ "${pkg_count}" -ne 4 ]]; then
        echo "Expected to find 4 packages, however only ${pkg_count} were detected. Some of the required \
omsagent packages are missing. Exiting the installation as it has failed to install all packages."
        exit 50
    fi
fi

chown -h omsagent:omiusers /var/opt/microsoft/omsconfig

# Backup the default configuration, at every deployment the rsyslog config will be first restored from default and then changed according to job properties
if [ ! -e /etc/opt/microsoft/omsagent/sysconf/95-omsagent.conf.bk ]; then
    cp /etc/rsyslog.d/95-omsagent.conf /etc/opt/microsoft/omsagent/sysconf/95-omsagent.conf.bk
fi

# Disable the default service
service omsagent-${workspace_id} stop
rm -f /etc/init.d/omsagent*
systemctl stop omsagent-${workspace_id}
systemctl disable omsagent-${workspace_id}
rm -f /lib/systemd/system/omsagent*

# Attempting to stop omid before monit takes over
echo "Stopping and disabling omid"
scxadmin -stop all
service omid stop || systemctl stop omid
systemctl disable omid
rm -f /etc/init.d/omid || rm -f /lib/systemd/system/omid.service

# Add the config for collecting uaa.log
if [ -f /var/vcap/sys/log/uaa/uaa.log ]; then
    cp -f /var/vcap/packages/omsagent/oms.uaa.conf /etc/opt/microsoft/omsagent/conf/omsagent.d/uaa.conf
fi
}

main "${@}"
