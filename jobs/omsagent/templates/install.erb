#!/bin/bash

# Primary Variables
PRODUCT="omsagent"
INSTALL_DIR="/var/vcap"
SYSLOG_DIR="${INSTALL_DIR}/sys/log"
PKG_DIR="${INSTALL_DIR}/packages/${PRODUCT}"
DATA_DIR="${INSTALL_DIR}/data"
INSTALLER=""
DPKG_TIMEOUT=300
DPKG_INSTALL_OPTS=("--force-confold" "--force-confdef")
RPM_INSTALL_OPTS=("--force")
CONTROLLER=""

# Template Variables
workspace_id=<%= p('oms.workspace_id') %>
workspace_key=<%= p('oms.workspace_key') %>
oms_top_level_domain=<%= p('oms.top_level_domain', "opinsights.azure.com") %>
rsyslog_port=<%= p('rsyslog.port', 25224) %>

# Package Variables and Versions
pkg_list=("omsconfig" "omsagent" "scx" "omi")

## omsagent 
omsagent_pkg="omsagent"
omsagent_ver="1.12.15-0.universal.x64"
omsagent_path="${PKG_DIR}/${omsagent_pkg}-${omsagent_ver}"

## omsconfig
omsconfig_pkg="omsconfig"
omsconfig_ver="1.1.1-927.x64"
omsconfig_path="${PKG_DIR}/${omsconfig_pkg}-${omsconfig_ver}"

## omi
omi_pkg="omi"
omi_ver="1.6.3-0.ulinux.x64"
omi_path="${PKG_DIR}/${omi_pkg}-${omi_ver}"

## scx
scx_pkg="scx"
scx_ver="1.6.3-1079.universal.x64"
scx_path="${PKG_DIR}/${scx_pkg}-${scx_ver}"

# Utilize the functions later
source "${PKG_DIR}/utils.sh"

# Exit Codes
DETECT_INSTALLER_FAILURE=65
DETECT_CONTROLLER_FAILURE=66
STOP_OMS_SERVICE_NO_SERVICE=67
PKG_CONTROL_NO_PACKAGE=68
PKG_CONTROL_INVALID_ACTION=69
PKG_CONTROL_MISSING_PKGS_INSTALL_FAILURE=70
RETRY_CREATE_SYMLINKS_TARGET_FAILURE=71
RETRY_CREATE_SYMLINKS_LINK_NAME_FAILURE=72
RETRY_CREATE_SYMLINKS_LINK_CREATE_FAILURE=73

# Wrapper for exiting
## $1 - exit code
trigger_exit(){
    echo "ERROR: pre-start script exiting with code ${1}"
    exit "${1}" 
}

# Verify the OS has dpkg or rpm package installer
detect_installer(){
    # Detect dpkg first
    which dpkg > /dev/null 2>&1 && INSTALLER="DPKG"

    # If dpkg wasn't found, check for rpm
    if [[ -z "${INSTALLER}" ]]; then
        which rpm > /dev/null 2>&1 && INSTALLER="RPM"

        # If rpm and dpkg aren't found, script needs to fail and exit
        if [[ -z "${INSTALLER}" ]]; then
            echo "ERROR: Unable to detect a valid installer binary. \
Valid installers are either \"dpkg\" or \"rpm\".

Either the PATH environment variable needs updated, or this script is being \
executed on an unsupported OS." >&2

            trigger_exit "${DETECT_INSTALLER_FAILURE}"
        fi
    fi
}

# Check if omsagent is already installed
detect_existing_install(){
    # This section checks for existing omsagent and omsconfig packages already installed.
    if [[ "${INSTALLER}" = "DPKG" ]]; then
        dpkg -s "${pkg_list[@]}" 2> /dev/null | grep "^Status:" | grep installed > /dev/null 2>&1
    else
        rpm -q "${pkg_list[@]}" > /dev/null 2>&1
    fi

    OMS_FOUND="${?}"
}

# Detect the service controller
detect_controller(){
    # Check the PATH for systemctl
    if which systemctl > /dev/null 2>&1; then
        CONTROLLER="systemctl"

    # Check for the binaries directly
    else
        if [[ -f "/bin/systemctl" ]]; then
            CONTROLLER="systemctl"
        elif [[ -f "/sbin/service" ]]; then
            CONTROLLER="service"
        elif [[ -f "/usr/sbin/invoke-rc.d" ]]; then
            CONTROLLER="invoke-rc.d"
        fi
    fi

    # Exit if no supported controllers found
    if [[ -z "${CONTROLLER}" ]]; then
        echo "ERROR: Unable to detect a supported controller.
Supported Controllers are 'systemctl', 'service' and 'invoke-rc'." >&2

        trigger_exit "${DETECT_CONTROLLER_FAILURE}"
    fi
}

# Function for stopping, disabling and killing 
### Action options: [stop] [disable] [kill]
### Services: [current_ws] [omsagent] [omid]
stop_oms_services(){
    # Initializing variables
    local service_stop=""
    local service_disable=""
    local service_kill=""
    local sev=""
    local sev_array=()

    # Regex for detecting the omsagent service
    reg="omsagent-[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}"

    # Loop through any options provided
    for stop_val in "${@}"; do
        if [[ "${stop_val}" == "stop" ]]; then
            service_stop="true"
        fi

        if [[ "${stop_val}" == "disable" ]]; then
            service_disable="true"
        fi

        if [[ "${stop_val}" == "kill" ]]; then
            service_kill="true"
        fi

        # Adds omsagent-workspace_id as one of the services to stop/disable/kill
        if [[ "${stop_val}" == "current_ws" ]]; then
            sev_array+=("omsagent-${workspace_id}")
        fi

        if [[ "${stop_val}" == "omsagent" ]]; then
            sev_array+=("omsagent")
        fi

        if [[ "${stop_val}" == "omid" ]]; then
            sev_array+=("omid")
        fi
    done

    # Check if sev_array is empty
    if [[ "${#sev_array[@]}" -eq 0 ]]; then
        echo -e "ERROR: No services provided to stop/disable/kill. Valid services are:
\t'omsagent'
\t'omid'
\t'current_ws' (this will stop/disable/kill 'omsagent-<workspace_id>')" >&2

        trigger_exit "${STOP_OMS_SERVICE_NO_SERVICE}"

    # Proceed if it is not empty
    else
        # Loop through all services added to the array
        for sev in "${sev_array[@]}"; do
            # invoke-rc.d method
            if [[ "${CONTROLLER}" == "invoke-rc.d" ]]; then
                if [[ "${sev}" == "omsagent" ]]; then
                    # Pull the name of the service
                    sev=$(ls /etc/init.d/ | grep -P "${reg}" -o)
                fi
    
                # Try to stop omsagent utilizing the controller
                if [[ "${service_stop}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Stopping ${sev} process via ${CONTROLLER}"
                    "${CONTROLLER}" "${sev}" stop
    
                    # for omid, try stopping it with the scxadmin binary too
                    if [[ "${sev}" == "omid" ]]; then
                        scxadmin -stop all
                    fi
                fi
    
                # Try to disable and wipe out the init scripts
                if [[ "${service_disable}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Attempting to disable ${sev} from starting."
                    update-rc.d "${sev}" disable
                    rm -fv "/etc/init.d/${sev}" 2>/dev/null
                fi
    
            # service method
            elif [[ "${CONTROLLER}" == "service" ]]; then
                if [[ "${sev}" == "omsagent" ]]; then
                    # Pull the name of the service
                    sev=$(service --status-all | grep -P "${reg}" -o)
                fi
    
                # Try to stop omsagent utilizing the controller
                if [[ "${service_stop}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Stopping ${sev} process via ${CONTROLLER}"
                    "${CONTROLLER}" "${sev}" stop
    
                    # for omid, try stopping it with the scxadmin binary too
                    if [[ "${sev}" == "omid" ]]; then
                        scxadmin -stop all
                    fi
                fi
    
                # Try to disable and wipe out the init scripts
                if [[ "${service_disable}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Attempting to disable ${sev} from starting."
                    chkconfig "${sev}" off
                    chkconfig --del "${sev}"
                    rm -fv "/etc/init.d/${sev}" 2>/dev/null
                fi
    
            # systemctl method
            else
                if [[ "${sev}" == "omsagent" ]]; then
                    # Pull the name of the service
                    sev=$("${CONTROLLER}" status | grep -P "${reg}" -o)
                fi
    
                if [[ "${service_stop}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Stopping ${sev} process via ${CONTROLLER}"
                    "${CONTROLLER}" stop "${sev}"
    
                    # for omid, try stopping it with the scxadmin binary too
                    if [[ "${sev}" == "omid" ]]; then
                        scxadmin -stop all
                    fi
                fi
    
                # Try to disable and wipe out the unit files
                if [[ "${service_disable}" == "true" && -n "${sev}" ]]; then
                    echo "INFO: Attempting to disable ${sev} from starting."
                    "${CONTROLLER}" disable "${sev}"
                    rm -fv "/lib/systemd/system/${sev}.service" 2>/dev/null
                fi
            fi
    
            if [[ "${service_kill}" == "true" && "${sev}" != "omid" ]]; then
                echo "INFO: Attempting to kill any omsagent PIDs still running..."
    
                # Pull PIDs for any process using the custom rsyslog port for omsagent
                current_pids=$(sudo netstat -anop | grep ${rsyslog_port} | cut -c 81- | cut -d'/' -f 1 | cut -d'-' -f 1)

                # If the array has at least 1 or more PIDs detected, loop through and kill them
                if [[ "${#current_pids[@]}" -gt 0 ]]; then 
                    # Looping through the pids
                    for current_pid in "${current_pids}"; do
                        if [[ -n "${current_pid}" ]]; then
                            echo "INFO: Killing ${current_pid} "
                            kill -9 "${current_pid}"
                        fi
                    done
                fi

                # Ensuring omiserver is stopped
                pkill -f "bin/omiserver" > /dev/null 2>&1    

                # Killing anything still running as the omsagent user
                pkill -u omsagent > /dev/null 2>&1
            fi
        done
    fi
}

# This function is used for installing or removing packages
## $1 - [install|remove|verify] : The action to take on the packages
## $2, $3, etc - [all|<pkg name>] : 'all' will install/remove/verify the entire 'pkg_list' array, or 
##                                  you can specify each package and it'll loop through them.
pkg_control(){
    local packages=()
    local install_array=()
    local pkg_action="${1}"

    # Ensure at least one package is provided
    if [[ -z "${2}" ]]; then
        echo -e "ERROR: No packages provided to pkg_control function. Unable to proceed." >&2
        trigger_exit "${PKG_CONTROL_NO_PACKAGE}"
    fi

    # Install packages
    if [[ "${pkg_action}" == "install" ]]; then
        if [[ "${2}" == "all" ]]; then
            install_array=("${pkg_list[@]}")

        else
            # Looping through packages provided to the function
            for pkg in "${@:2}"; do
                install_array+=("${pkg}")
            done
        fi

        if [[ "${INSTALLER}" = "DPKG" ]]; then
            # Building packages array with paths to each .deb package to install
            for inst_pkg in "${install_array[@]}"; do
                pkg_path="${inst_pkg}_path"
    
                packages+=("${!pkg_path}.deb")
            done

            # Perform the install
            (
            # Get a lock to prevent other bad actors running dpkg commands
            # e.g. bosh running parallel requests that might interfere
            flock -x 200
        
            # Used as a timeout
            DPKG_RETRIES=0
        
            # Checks dpkg/apt related lock files to see if they're already locked and in use
            # Also checks if DPKG_RETRIES hit the timeout value
            while fuser /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock >/dev/null 2>&1 \
&& [ "${DPKG_RETRIES}" -lt "${DPKG_TIMEOUT}" ]; do
                DPKG_RETRIES=$(( DPKG_RETRIES + 1 ))
                sleep 1
            done

            echo "INFO: Installing these packages: ${packages[@]}"
            dpkg -i "${DPKG_INSTALL_OPTS}" "${packages[@]}" || true
            ) 200>"${DATA_DIR}/dpkg.lock"

        # RPM
        else
            # Building packages array with paths to each .rpm package to install
            for inst_pkg in "${install_array[@]}"; do
                pkg_path="${inst_pkg}_path"

                packages+=("${!pkg_path}.rpm")
            done

            # Perform the install
            echo "INFO: Installing these packages: ${packages[@]}"
            rpm -Uvh "${RPM_INSTALL_OPTS}" "${packages[@]}"
        fi

    # Remove packages
    elif [[ "${pkg_action}" == "remove" ]]; then
        # If we're removing all packages
        if [[ "${2}" == "all" ]]; then
            packages=("${pkg_list[@]}")

        # Otherwise build the array from packages provided skipping the first variable
        else
            for pkg in "${@:2}"; do
                packages+=("${pkg}")
            done
        fi

        # DPKG removal
        if [[ "${INSTALLER}" = "DPKG" ]]; then
            # dpkg lock control and perform the removal
            (
            # Get a lock to prevent other bad actors running dpkg commands
            # e.g. bosh running parallel requests that might interfere
            flock -x 200

            # Used as a timeout
            DPKG_RETRIES=0

            # Checks dpkg/apt related lock files to see if they're already locked and in use
            # Also checks if DPKG_RETRIES hit the timeout value
            while fuser /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock >/dev/null 2>&1 \
&& [ "${DPKG_RETRIES}" -lt "${DPKG_TIMEOUT}" ]; do
                DPKG_RETRIES=$(( DPKG_RETRIES + 1 ))
                sleep 1
            done

            echo "INFO: Removing these packages: ${packages[@]}"
            dpkg -r "${packages[@]}"
            ) 200>"${DATA_DIR}/dpkg.lock"

        # RPM removal
        else
            echo "INFO: Removing these packages: ${packages[@]}"
            rpm -e "${packages[@]}"
        fi

    # Verifying packages are installed
    elif [[ "${pkg_action}" == "verify" ]]; then
        # If we're verifying all packages
        if [[ "${2}" == "all" ]]; then
            packages=("${pkg_list[@]}")

        # Otherwise build the array from packages provided skipping the first variable
        else
            for pkg in "${@:2}"; do
                packages+=("${pkg}")
            done
        fi

        # Initializing vars
        local pkg_count=0
        local expected_count="${#packages[@]}"

        # Pull the count on packages to see how many are installed
        if [[ "${INSTALLER}" == "DPKG" ]]; then
            pkg_count=$(dpkg -l "${packages[@]}" | grep -c "^ii ")
        else
            pkg_count=$(rpm -q "${packages[@]}" | grep -v "is not installed" | wc -l)
        fi
    
        # Output some information and exit if all packages are not found.
        if [[ "${pkg_count}" -ne "${expected_count}" ]]; then
            echo "ERROR: Expected to find ${expected_count} package(s), \
however only ${pkg_count} were detected. Some of the required omsagent \
packages are missing.
Exiting the installation as it has failed to install all required packages." >&2

            trigger_exit "${PKG_CONTROL_MISSING_PKGS_INSTALL_FAILURE}"
        fi
        
    # Enters here if an invalid action is provided
    else
        echo -e "ERROR: Invalid action provided to pkg_control function. Valid actions are:
\t'install'
\t'remove'
\t'verify'" >&2

        trigger_exit "${PKG_CONTROL_INVALID_ACTION}"
    fi
}

# This function is used to safely create the necessary symlinks
## $1 - Symlink Existing Target
## $2 - Symlink Link Name
retry_create_symlinks(){
    local TARGET="${1}"
    local LINK_NAME="${2}"
    local RETRIES=2

    # Ensure we have a TARGET file/directory
    if [[ -z "${TARGET}" ]]; then
        echo -e "ERROR: Function 'retry_create_symlinks' called with the \
TARGET file/directory missing." >&2
        trigger_exit "${RETRY_CREATE_SYMLINKS_TARGET_FAILURE}"
    fi

    # Ensure we have the expected link name
    if [[ -z "${LINK_NAME}" ]]; then
        echo -e "ERROR: Function 'retry_create_symlinks' called with the \
expected link name missing." >&2
        trigger_exit "${RETRY_CREATE_SYMLINKS_LINK_NAME_FAILURE}"
    fi

    # Verify that the expected link doesn't already exist as a symlink.
    if [[ ! -L "${LINK_NAME}" ]]; then
        while [[ "${RETRIES}" -gt 0 ]]; do

            # If LINK_NAME exists and is a directory, backup the logs and 
            # then recreate it as a symlink
            if [[ -d "${LINK_NAME}" ]]; then
                echo "INFO: Link name exists as a directory. Backing up log \
files and removing before attempting to create the symlink."

                mv -vf ${LINK_NAME}/* "${TARGET}/"
                rm -rvf "${LINK_NAME}"
            fi

            # Create the symlink
            echo "INFO: Attempting to create a symlink pointing ${LINK_NAME} to ${TARGET}"
            ln -s "${TARGET}" "${LINK_NAME}"

            # If the link exists, break out of the loop
            if [[ -L "${LINK_NAME}" ]]; then
                echo "INFO: Link successfully created pointing ${LINK_NAME} to ${TARGET}"
                break
            fi

            # Countdown to zero
            RETRIES=$((RETRIES - 1))
        done

        # If we reach zero and the link still hasn't been created, then mark the creation
        # as a failure and exit.
        if [[ "${RETRIES}" -eq 0 ]]; then
            echo "ERROR: Failed to create symlink pointing ${LINK_NAME} to ${TARGET}" >&2
            trigger_exit "${RETRY_CREATE_SYMLINKS_LINK_CREATE_FAILURE}"
        fi
    fi
}

configure_users(){
    local count=0

    ### User/Group Creation and Permissions
    echo "INFO: Using identity $(id)."

    count=$(grep -c '^omsagent:' /etc/group)
    if [[ "${count}" == 0 ]]; then
        # Create new user group omsagent
        echo "INFO: Creating group \"omsagent\""
        groupadd -f "omsagent"
    fi
    
    count=$(grep -c '^omiusers:' /etc/group)
    if [ "${count}" == 0 ]; then
        # Create new user group omiusers
        echo "INFO: Creating group \"omiusers\""
        groupadd -f "omiusers"
    fi
    
    count=$(grep -c '^omsagent:' /etc/passwd)
    if [ "${count}" == 0 ]; then
        # Create new user account omsagent
        echo "INFO: Creating user \"omsagent\""
        useradd -M -N -s /bin/bash "omsagent"
    fi

    # Adding users to the appropriate groups
    echo "INFO: Configuring groups"    
    usermod -aG omsagent omsagent
    usermod -aG omiusers omsagent
    
    # Permissions
    echo "INFO: Ensuring permissions are correct."
    chown -h omsagent:omiusers "${OPT_DIR}/microsoft/omsconfig"
    chown -h omsagent:omsagent "${SYSLOG_DIR}/omsconfig"
    
    # Add oms users to vcap group for file system access
    usermod -aG vcap omsagent
    usermod -aG vcap nxautomation
}

main(){
    # Verify the OS has a valid package installer
    detect_installer

    # Detect the service controller
    detect_controller

    # Check if there is an existing omsagent installation
    detect_existing_install

    # Enters here if an existing omsagent installation was found
    if [[ "${OMS_FOUND}" -eq 0 ]]; then
        echo "INFO: Existing omsagent detected. Ensuring it's stopped and disabled."

        # Stop existing omsagent processes
        stop_oms_services stop disable kill omsagent

        # Remove related packages
        pkg_control remove omsconfig omsagent
    fi

    # Check for scx, stop and remove it
    which scxadmin > /dev/null 2>&1

    # If scxadmin is detected
    if [[ "${?}" -eq 0 ]]; then
        echo "INFO: Detected 'scx' installed; stopping and removing related packages."

        # Stop and disable omid which is controlled by scxadmin
        stop_oms_services stop disable omid
    
        # Remove related packages
        pkg_control remove omi scx
    fi

    # Removing the file to ensure onboarding is triggered upon re-installation.
    # Checks to see if the file exists, and that it is empty before removal.
    if [[ -f "/etc/opt/microsoft/omsagent/${workspace_id}/conf/.service_registered" && \
! -s "/etc/opt/microsoft/omsagent/${workspace_id}/conf/.service_registered" ]]; then
        echo "INFO: '.service_registered' file detected - removing it now."
        rm -vf "/etc/opt/microsoft/omsagent/${workspace_id}/conf/.service_registered"
    fi

    # Custom Directory Creation
    mkdir -p "${OPT_DIR}/omi"
    mkdir -p "${OPT_DIR}/microsoft/scx"

    ### These are for redirecting logs
    mkdir -p "${SYSLOG_DIR}/omi"
    mkdir -p "${SYSLOG_DIR}/scx"
    mkdir -p "${SYSLOG_DIR}/omsconfig"
    
    # Create the symlinks for the above log directories 
    retry_create_symlinks "${SYSLOG_DIR}/omi" "${OPT_DIR}/omi/log"
    retry_create_symlinks "${SYSLOG_DIR}/scx" "${OPT_DIR}/microsoft/scx/log"
    retry_create_symlinks "${SYSLOG_DIR}/omsconfig" "${OPT_DIR}/microsoft/omsconfig"

    # Ensures all necessary users/groups and permissions are configured
    configure_users

    # Copying logrotate for scx
    if [[ -f "${PKG_DIR}/logrotate.scx.conf" ]]; then
        echo "INFO: Installing logrotate config for scx."
        cp -vf "${PKG_DIR}/logrotate.scx.conf" /etc/logrotate.d/scx
    fi

    # Write the onboard config
    echo "INFO: Creating omsagent-onboard.conf"
    cat <<EOF > /etc/omsagent-onboard.conf
WORKSPACE_ID=$workspace_id
SHARED_KEY=$workspace_key
URL_TLD=$oms_top_level_domain
EOF

    # Ensure omsagent remnants aren't running
    # Had issues with dpkg locks due to omiserver still running
    stop_oms_services kill omsagent

    # Installing required packages
    pkg_control install all

    # Verifying installation was successful
    pkg_control verify all

    # Ensures all necessary users/groups and permissions are configured
    configure_users

    # Backup the default configuration
    # At every deployment the rsyslog config will be first restored from default and then changed according to job properties
    if [[ ! -e "/etc/opt/microsoft/omsagent/sysconf/95-omsagent.conf.bk" ]]; then
        echo "INFO: Backing up 95-omsagent.conf"
        cp -v /etc/rsyslog.d/95-omsagent.conf /etc/opt/microsoft/omsagent/sysconf/95-omsagent.conf.bk
    fi

    # Stop and disable current omsagent
    stop_oms_services stop disable current_ws

    # Stop and disable omid
    stop_oms_services stop disable omid

    # Add the config for collecting uaa.log
    if [[ -f "${SYSLOG_DIR}/uaa/uaa.log" ]]; then
        echo "INFO: Installing uaa.conf for omsagent"
        cp -vf "${PKG_DIR}/oms.uaa.conf" /etc/opt/microsoft/omsagent/conf/omsagent.d/uaa.conf
    fi

    echo "INFO: Installation has completed successfully."
}

main "${@}"
